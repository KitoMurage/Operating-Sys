_attribute__((noreturn))
void run_command(char *buf, int nbuf, int *pcp) {
    /* Useful data structures and flags. */
    char *arguments[10];
    int numargs = 0;
    /* Word start/end */
    int ws = 1;
    int we = 0;

    int redirection_left = 0;
    int redirection_right = 0;
    char *file_name_l = 0;
    char *file_name_r = 0;

    int p[2];
    int pipe_cmd = 0;

    int sequence_cmd = 0;

    int i = 0;
    fprintf(1, "test 1");
    /* Parse the command character by character. */
    for (; i < nbuf; i++) {
        char c = buf[i];
        /* Parse the current character and set-up various flags:
           sequence_cmd, redirection, pipe_cmd and similar. */

        /* ##### Place your code here. */
        if (!(redirection_left || redirection_right)) {
            /* No redirection, continue parsing command. */
          fprintf(1, "test 2");
            switch (c) {
                case ';':
                    buf[i] = '\0';
                    sequence_cmd = 1;
                    break;

                case '|':
                    buf[i] = '\0';
                    pipe_cmd = 1;
                    break;

                case '<':
                    redirection_left = 1;
                    buf[i] = '\0';
                    file_name_l = &buf[i + 1];
                    break;

                case '>':
                    redirection_right = 1;
                    buf[i] = '\0';
                    file_name_r = &buf[i + 1];
                    break;

                case '\0':
                    if (!ws) {
                        buf[i] = '\0';
                        arguments[numargs++] = &buf[we];
                    }
                    break;

                default:
                    if (c != ' ' && c != '\t' && c != '\n') {
                        if (ws) {
                            ws = 0;
                            we = i;
                        }
                    } else {
                        if (!ws) {
                            buf[i] = '\0';
                            arguments[numargs++] = &buf[we];
                            ws = 1;
                        }
                    }
                    break;
            }
	} else {
            /* Redirection command. Capture the file names. */
            if (c == '<') {
                fprintf(1, "Detected left redirection\n");
                redirection_left = 1;
                buf[i] = '\0';
                file_name_l = &buf[i + 1];
            } else if (c == '>') {
                fprintf(1, "Detected right redirection\n");
                redirection_right = 1;
                buf[i] = '\0';
                file_name_r = &buf[i + 1];
            }
	}
    }

    /*
      Sequence command. Continue this command in a new process.
      Wait for it to complete and execute the command following ';'.
    */
    fprintf(1, "test 3");
    if (sequence_cmd) {
        sequence_cmd = 0;
        if (fork() != 0) {
            wait(0);
            // ##### Place your code here.
            // Possibly handle the next command after the ';' here
        } else {
            exec(arguments[0], arguments);
            fprintf(2, "Sequence command execution failed\n");
            exit(1);
        }
    }

    /*
      If this is a redirection command,
      tie the specified files to std in/out.
    */

    fprintf(1, "test 4");
    if (redirection_left) {
        // ##### Place your code here.
        int fd = open(file_name_l, O_RDONLY);
        if (fd < 0) {
            fprintf(2, "Error opening input file: %s\n", file_name_l);
            exit(1);
        }
	close(0); // Close stdin
        dup(fd);  // Redirect stdin to the file
        close(fd); // Close original file descriptor
    }

    if (redirection_right) {
        // ##### Place your code here.
        int fd = open(file_name_r, O_WRONLY | O_CREATE);
        if (fd < 0) {
            fprintf(2, "Error opening output file: %s\n", file_name_r);
            exit(1);
        }
	close(1); // Close stdout
        dup(fd);  // Redirect stdout to the file
        close(fd); // Close original file descriptor
    }

    /* Parsing done. Execute the command. */
    fprintf(1, "test 5");
    arguments[numargs] = 0; // Null-terminate arguments array
    fprintf(1, "Executing command: %s with arguments:\n", arguments[0]);
    for (int k = 0; k < numargs; k++) {
        fprintf(1, "  %s\n", arguments[k]);
    }

    if (exec(arguments[0], arguments) < 0) {
        fprintf(2, "Command execution failed: %s\n", arguments[0]);
        for (int k = 0; k < numargs; k++){
          fprintf(2, "Arg[%d]: %s\n", k, arguments[k]);
        }
	exit(1);
    }

    // Handle CD command without forking
    fprintf(1, "test 6");

    if (strcmp(arguments[0], "cd") == 0) {
