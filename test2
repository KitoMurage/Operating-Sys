#include "kernel/types.h"
#include "user/user.h"
#include "kernel/fcntl.h"
#include <string.h>

/* Read a line of characters from stdin. */
int getcmd(char *buf, int nbuf) {
    fprintf(1, ">>> ");
    memset(buf, 0, nbuf);
    if (gets(buf, nbuf) == 0) {
        fprintf(2, "error\n");
        return -1;
    }

    // Remove leading white space
    int i = 0;
    while (buf[i] == ' ' || buf[i] == '\t') {
        i++;
    }
    if (i > 0) {
        memmove(buf, &buf[i], strlen(buf) - i + 1);
    }
    // Remove trailing white space
    int len = strlen(buf);
    while (len > 0 && (buf[len - 1] == ' ' || buf[len - 1] == '\t' || buf[len - 1] == '\n')) {
        len--;
    }
    buf[len] = '\0';

    // Remove space between
    int j = 0;
    for (i = 0; i < len; i++) {
        if (buf[i] != ' ' && buf[i] != '\t') {
            buf[j++] = buf[i];
        } else if (j > 0 && buf[j - 1] != ' ') {
            buf[j++] = ' ';
        }
    }
    buf[j] = '\0';
    if (strlen(buf) == 0) {
        fprintf(2, "Error: empty command\n");
        return -1;
    }
    return 0;
}

/*
  A recursive function which parses the command
  at *buf and executes it.
*/
__attribute__((noreturn))
void run_command(char *buf, int nbuf, int *pcp) {
    /* Useful data structures and flags. */
    char *arguments[10];
    int numargs = 0;
    int ws = 1; // Word start
    int we = 0; // Word end
    int redirection_left = 0;
    int redirection_right = 0;
    char *file_name_l = 0;
    char *file_name_r = 0;
    int pipe_cmd = 0;
    int sequence_cmd = 0;

    for (int i = 0; i < nbuf; i++) {
        char c = buf[i];

        if (c == '\0' || c == '\n') {
            if (!ws) {
                buf[i] = '\0';
                arguments[numargs++] = &buf[we];
            }
            break;
        }

        if (!(redirection_left || redirection_right)) {
            switch (c) {
                case ';':
                    buf[i] = '\0';
                    sequence_cmd = 1;
                    break;
                case '|':
                    buf[i] = '\0';
                    pipe_cmd = 1;
                    break;
                case '<':
                    redirection_left = 1;
                    buf[i] = '\0';
                    file_name_l = &buf[i + 1];
                    break;
                case '>':
                    redirection_right = 1;
                    buf[i] = '\0';
                    file_name_r = &buf[i + 1];
                    break;
                default:
                    if (c != ' ' && c != '\t') {
                        if (ws) {
                            ws = 0;
                            we = i;
                        }
                    } else {
                        if (!ws) {
                            buf[i] = '\0';
                            arguments[numargs++] = &buf[we];
                            ws = 1;
                        }
                    }
                    break;
            }
        } else {
            if (c == '<' || c == '>') {
                buf[i] = '\0'; // End the command for redirection
                if (c == '<') {
                    file_name_l = &buf[i + 1];
                } else if (c == '>') {
                    file_name_r = &buf[i + 1];
                }
            }
        }
    }

    if (sequence_cmd) {
        sequence_cmd = 0;
        if (fork() == 0) {
            exec(arguments[0], arguments);
            fprintf(2, "Command execution failed\n");
            exit(1);
        }
        wait(0); // Wait for the first command to finish
        run_command(&buf[strlen(buf) + 1], nbuf - strlen(buf) - 1, pcp); // Execute the next command
        exit(0);
    }

    // Handle redirections
    if (redirection_left) {
        int fd = open(file_name_l, O_RDONLY);
        if (fd < 0) {
            fprintf(2, "Error opening input file: %s\n", file_name_l);
            exit(1);
        }
        close(0); // Close stdin
        dup(fd);  // Redirect stdin to the file
        close(fd); // Close original file descriptor
    }

    if (redirection_right) {
        int fd = open(file_name_r, O_WRONLY | O_CREATE);
        if (fd < 0) {
            fprintf(2, "Error opening output file: %s\n", file_name_r);
            exit(1);
        }
        close(1); // Close stdout
        dup(fd);  // Redirect stdout to the file
        close(fd); // Close original file descriptor
    }

    // Handle pipes
    if (pipe_cmd) {
        int p[2];
        pipe(p);
        if (fork() == 0) {
            // First child for left side of the pipe
            close(1); // Close stdout
            dup(p[1]); // Redirect stdout to pipe
            close(p[0]); // Close read end of pipe
            exec(arguments[0], arguments); // Execute command
            fprintf(2, "exec %s failed\n", arguments[0]);
            exit(1);
        }

        if (fork() == 0) {
            // Second child for right side of the pipe
            close(0); // Close stdin
            dup(p[0]); // Redirect stdin to read from pipe
            close(p[1]); // Close write end of pipe
            run_command(&buf[i + 1], nbuf - i - 1, pcp); // Recursively handle the right side
            exit(0);
        }

        close(p[0]); // Close read end in parent
        close(p[1]); // Close write end in parent
        wait(0); // Wait for first child
        wait(0); // Wait for second child
    } else {
        // Execute the command normally if not a pipe
        if (numargs > 0) {
            exec(arguments[0], arguments);
            fprintf(2, "exec %s failed\n", arguments[0]);
        }
    }
    exit(0);
}

int main(void) {
    static char buf[100];

    int pcp[2];
    pipe(pcp);

    /* Read and run input commands. */
    while (getcmd(buf, sizeof(buf)) >= 0) {
        if (fork() == 0) {
            run_command(buf, 100, pcp);
        }

        /*
          Check if run_command found this is
          a CD command and run it if required.
        */
        int child_status;
        wait(&child_status);
        if (child_status == 2) {
            char new_dir[100];
            if (read(pcp[0], new_dir, sizeof(new_dir)) > 0) {
                if (chdir(new_dir) < 0) {
                    fprintf(2, "failed\n");
                }
            }
        }
    }
    exit(0);
}
