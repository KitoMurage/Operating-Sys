#include "kernel/types.h"
#include "user/user.h"
#include "kernel/fcntl.h"

/* Read a line of characters from stdin. */
int getcmd(char *buf, int nbuf) {
    if (read(0, buf, nbuf) < 0) {
        return -1; // Error on read
    }

    // Remove the trailing newline character
    int i = 0;
    while (i < nbuf && buf[i] != '\n') {
        i++;
    }
    buf[i] = '\0'; // Null-terminate the string
    return 0; // Success
}

/*
  A recursive function which parses the command
  at *buf and executes it.
*/
__attribute__((noreturn))
void run_command(char *buf, int nbuf, int *pcp) {
    /* Useful data structures and flags. */
    char *arguments[10];
    int numargs = 0;
    /* Word start/end */
    int ws = 1; // whitespace flag
    int we = 0; // end of word

    int redirection_left = 0;
    int redirection_right = 0;
    char *file_name_l = 0;
    char *file_name_r = 0;

    int p[2];
    int pipe_cmd = 0;

    int sequence_cmd = 0;

    int i = 0;

    /* Parse the command character by character. */
    for (; i < nbuf; i++) {
        char c = buf[i];

        /* Handle spaces */
        if (c == ' ' || c == '\t') {
            if (!ws) {
                buf[i] = '\0'; // Null-terminate the current argument
                arguments[numargs++] = &buf[we]; // Add argument
                ws = 1; // Set whitespace flag
            }
        } else {
            if (ws) {
                we = i; // Update end of word
            }
            ws = 0; // Not whitespace anymore

            /* Handle redirection */
            if (c == '<') {
                redirection_left = 1;
                file_name_l = &buf[i + 1]; // Assume filename follows
                while (buf[i + 1] == ' ') i++; // Skip spaces
            } else if (c == '>') {
                redirection_right = 1;
                file_name_r = &buf[i + 1]; // Assume filename follows
                while (buf[i + 1] == ' ') i++; // Skip spaces
            } else if (c == '|') {
                pipe_cmd = 1;
                buf[i] = '\0'; // End the current command
            } else if (c == ';') {
                sequence_cmd = 1;
                buf[i] = '\0'; // End the current command
                // Process left command before the next semicolon
                run_command(&buf[0], nbuf, pcp);
                // Reset to handle next command
                memset(buf, 0, sizeof(buf));
                return; // Exit current execution
            }
        }
    }

    // Handle the last argument
    if (!ws) {
        buf[i] = '\0';
        arguments[numargs++] = &buf[we];
    }
    arguments[numargs] = 0; // Null-terminate the arguments array

    /*
      Sequence command. Continue this command in a new process.
      Wait for it to complete and execute the command following ';'.
    */
    if (sequence_cmd) {
        sequence_cmd = 0;
        if (fork() != 0) {
            wait(0);
            // ##### Place your code here.
        }
    }

    /*
      If this is a redirection command,
      tie the specified files to std in/out.
    */
    if (redirection_left) {
        int fd = open(file_name_l, O_RDONLY);
        if (fd < 0) {
            fprintf(2, "Cannot open %s for reading\n", file_name_l);
            exit(1);
        }
        // Redirect stdin
        if (fork() == 0) {
            dup(fd, 0); // Assuming dup can be used
            close(fd);
            exec(arguments[0], arguments); // Execute the command
            fprintf(2, "exec %s failed\n", arguments[0]);
            exit(1); // Exit if exec fails
        }
        wait(0); // Parent waits for the child
    }

    if (redirection_right) {
        int fd = open(file_name_r, O_WRONLY | O_CREATE);
        if (fd < 0) {
            fprintf(2, "Cannot open %s for writing\n", file_name_r);
            exit(1);
        }
        // Redirect stdout
        if (fork() == 0) {
            dup(fd, 1); // Assuming dup can be used
            close(fd);
            exec(arguments[0], arguments); // Execute the command
            fprintf(2, "exec %s failed\n", arguments[0]);
            exit(1); // Exit if exec fails
        }
        wait(0); // Parent waits for the child
    }

    /* Parsing done. Execute the command. */

    /*
      If this command is a CD command, write the arguments to the pcp pipe
      and exit with '2' to tell the parent process about this.
    */
    if (strcmp(arguments[0], "cd") == 0) {
        if (arguments[1] == 0) {
            fprintf(2, "cd: missing argument\n");
        } else if (chdir(arguments[1]) < 0) {
            fprintf(2, "cd: %s: No such file or directory\n", arguments[1]);
        }
        exit(2); // Exit with a special status for cd
    } else {
        /*
          Pipe command: fork twice. Execute the left hand side directly.
          Call run_command recursion for the right side of the pipe.
        */
        if (pipe_cmd) {
            // Create a pipe
            pipe(p);
            if (fork() == 0) {
                dup(p[1], 1); // Redirect stdout to the pipe
                close(p[0]);
                exec(arguments[0], arguments); // Execute left command
                fprintf(2, "exec %s failed\n", arguments[0]);
                exit(1);
            } else {
                if (fork() == 0) {
                    dup(p[0], 0); // Redirect stdin from the pipe
                    close(p[1]);
                    run_command(&buf[i + 1], nbuf, pcp); // Execute right command
                }
            }
            close(p[0]);
            close(p[1]);
            wait(0); // Wait for left command
            wait(0); // Wait for right command
        } else {
            int pid = fork();
            if (pid == 0) {
                exec(arguments[0], arguments); // Execute normal command
                fprintf(2, "exec %s failed\n", arguments[0]);
                exit(1); // Exit if exec fails
            } else {
                wait(0); // Parent waits for the child to finish
            }
        }
    }
    exit(0);
}

int main(void) {
    static char buf[100];

    int pcp[2];
    pipe(pcp);

    /* Read and run input commands. */
    while (getcmd(buf, sizeof(buf)) >= 0) {
        if (fork() == 0)
            run_command(buf, 100, pcp);

        /*
          Check if run_command found this is
          a CD command and run it if required.
        */
        int child_status;
        wait(&child_status);
        // Check if the command was a cd command
        if (WEXITSTATUS(child_status) == 2) {
            // You can handle special case for 'cd' if needed
        }
    }
    exit(0);
}
