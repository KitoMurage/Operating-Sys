#include "kernel/types.h"
#include "user/user.h"
#include "kernel/fcntl.h"

int getcmd(char *buf, int nbuf) {
    printf(">>> ");              // Display the prompt
    memset(buf, 0, nbuf);         // Clear the buffer to avoid leftover data

    if (read(0, buf, nbuf) <= 0)  // Read input from stdin
        return -1;                // Return -1 on EOF or error
    return 0;
}

__attribute__((noreturn))
void run_command(char *buf, int nbuf, int *pcp) {
    char *arguments[10];
    int numargs = 0;
    int ws = 1;
    int we = 0;

    int redirection_left = 0;
    int redirection_right = 0;
    char *file_name_l = 0;
    char *file_name_r = 0;

    int p[2];
    int pipe_cmd = 0;
    int sequence_cmd = 0;

    int i = 0;
    
    // Parse the command character by character
    for (; i < nbuf && buf[i] != '\0' && buf[i] != '\n'; i++) {
        if (buf[i] == ' ' || buf[i] == '\t') {
            if (we) {                   // If end of a word is reached
                buf[i] = '\0';          // Null-terminate the argument
                we = 0;                 // Reset end flag
                numargs++;              // Increase argument count
            }
            ws = 1;                     // Set start flag for next word
        } else if (buf[i] == '>') {
            redirection_right = 1;
            file_name_r = buf + i + 1;  // File name starts after '>'
            while (*file_name_r == ' ' || *file_name_r == '\t') file_name_r++; // Skip whitespace
        } else if (buf[i] == '<') {
            redirection_left = 1;
            file_name_l = buf + i + 1;  // File name starts after '<'
            while (*file_name_l == ' ' || *file_name_l == '\t') file_name_l++; // Skip whitespace
        } else if (buf[i] == '|') {
            pipe_cmd = 1;
            buf[i] = '\0';  // Null-terminate the left command
            break;
        } else if (buf[i] == ';') {
            sequence_cmd = 1;
            buf[i] = '\0';  // Null-terminate the command sequence
            break;
        } else {
            if (ws) {                 // Start of a new word
                arguments[numargs] = buf + i;  // Capture argument start
                ws = 0;              // Reset start flag
            }
            we = 1;  // End flag for argument
        }
    }
    arguments[numargs] = 0;  // Null-terminate the argument list

    if (sequence_cmd) {
        sequence_cmd = 0;
        if (fork() != 0) {
            wait(0);
            run_command(buf + i + 1, nbuf - i - 1, pcp);  // Recur for next command
        }
    }

    // Handle redirection
    if (redirection_left) {
        int fd = open(file_name_l, O_RDONLY);
        if (fd >= 0) {
            close(0);      // Close stdin
            dup(fd);       // Redirect stdin to file descriptor
            close(fd);
        } else {
            printf("Error opening input file %s\n", file_name_l);
        }
    }
    if (redirection_right) {
        int fd = open(file_name_r, O_WRONLY | O_CREATE);
        if (fd >= 0) {
            close(1);      // Close stdout
            dup(fd);       // Redirect stdout to file descriptor
            close(fd);
        } else {
            printf("Error opening output file %s\n", file_name_r);
        }
    }

    if (strcmp(arguments[0], "cd") == 0) {
        if (numargs < 2 || chdir(arguments[1]) < 0) {
            printf("cd: %s: No such file or directory\n", arguments[1]);
        }
        exit(2);  // Exit with status 2 to indicate a "cd" command
    } else {
        if (pipe_cmd) {
            pipe(p);
            if (fork() == 0) {  // Left side of pipe
                close(1);       // Close stdout
                dup(p[1]);      // Redirect stdout to pipe write
                close(p[0]);
                close(p[1]);
                run_command(buf, i, pcp);  // Run left side command
                exit(0);
            }
            if (fork() == 0) {  // Right side of pipe
                close(0);       // Close stdin
                dup(p[0]);      // Redirect stdin to pipe read
                close(p[0]);
                close(p[1]);
                run_command(buf + i + 1, nbuf - i - 1, pcp);  // Run right side command
                exit(0);
            }
            close(p[0]);
            close(p[1]);
            wait(0);  // Wait for left
            wait(0);  // Wait for right
        } else {
            if (fork() == 0) {
                exec(arguments[0], arguments);  // Execute the command
                printf("exec %s failed\n", arguments[0]);
                exit(1);
            }
            wait(0);  // Wait for execution to complete
        }
    }
    exit(0);
}

int main(void) {
    static char buf[100];
    int pcp[2];
    pipe(pcp);

    // Read and run input commands
    while (getcmd(buf, sizeof(buf)) >= 0) {
        if (fork() == 0)
            run_command(buf, 100, pcp);  // Execute in child process

        int child_status;
        wait(&child_status);  // Wait for child process

        if (WIFEXITED(child_status) && WEXITSTATUS(child_status) == 2) {
            // Check if run_command executed "cd"
            char new_path[100];
            read(pcp[0], new_path, sizeof(new_path));  // Read path if "cd" was called
            chdir(new_path);  // Update directory
        }
    }
    exit(0);
}
